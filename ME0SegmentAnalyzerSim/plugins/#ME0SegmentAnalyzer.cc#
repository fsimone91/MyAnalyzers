//Package:    ME0SegmentAnalyzer
// Class:      ME0SegmentAnalyzer
// 
/**\class ME0SegmentAnalyzer ME0SegmentAnalyzer ME0SegmentAnalyzer/ME0SegmentAnalyzer/plugins/ME0SegmentAnalyzer.cc
 
 Description: [one line class summary]
 
 Implementation:
 [Notes on implementation]
 */
//
// Original Author:  
//         Created:  Fri, 09 Oct 2015 10:34:53 GMT
// $Id$
//
//


// system include files
#include <memory>
#include <algorithm>
#include <iostream>
// user include files
#include "FWCore/Framework/interface/Frameworkfwd.h"
#include "FWCore/Framework/interface/EDAnalyzer.h"

#include "FWCore/Framework/interface/Event.h"
#include "FWCore/Framework/interface/MakerMacros.h"
#include "RecoMuon/MuonIdentification/interface/ME0MuonSelector.h"
#include <DataFormats/MuonReco/interface/ME0Muon.h>
#include <DataFormats/MuonReco/interface/Muon.h>
#include <DataFormats/MuonReco/interface/ME0MuonCollection.h>
#include <DataFormats/GEMRecHit/interface/ME0RecHit.h>
#include "DataFormats/MuonDetId/interface/GEMDetId.h"
#include "DataFormats/GEMRecHit/interface/ME0RecHitCollection.h"
#include "DataFormats/HepMCCandidate/interface/GenParticle.h"
#include "DataFormats/HepMCCandidate/interface/GenParticleFwd.h"
#include "DataFormats/Math/interface/deltaR.h"
#include "FWCore/ServiceRegistry/interface/Service.h"

#include "DataFormats/GeometrySurface/interface/LocalError.h"
#include "DataFormats/GeometryVector/interface/LocalPoint.h"
#include "DataFormats/Scalers/interface/DcsStatus.h"
#include "DataFormats/Common/interface/Handle.h"
#include "DataFormats/Math/interface/deltaPhi.h"
#include "DataFormats/TrackReco/interface/TrackFwd.h"
//Geom
#include "Geometry/Records/interface/MuonGeometryRecord.h"
#include "Geometry/CommonDetUnit/interface/GeomDet.h"
#include "Geometry/GEMGeometry/interface/ME0Geometry.h"
#include <Geometry/GEMGeometry/interface/ME0EtaPartition.h>
#include <DataFormats/MuonDetId/interface/ME0DetId.h>

#include "Geometry/GEMGeometry/interface/GEMEtaPartition.h"
#include "Geometry/GEMGeometry/interface/GEMEtaPartitionSpecs.h"
#include "Geometry/CommonTopologies/interface/StripTopology.h"


#include "Geometry/Records/interface/GlobalTrackingGeometryRecord.h"
#include "Geometry/CommonDetUnit/interface/GlobalTrackingGeometry.h"
#include "Geometry/CommonDetUnit/interface/GeomDet.h"
#include "DataFormats/TrackReco/interface/Track.h"
#include "SimDataFormats/TrackingHit/interface/PSimHitContainer.h"
#include "SimDataFormats/Track/interface/SimTrackContainer.h"
#include "DataFormats/GEMDigi/interface/ME0DigiPreRecoCollection.h"
#include "DataFormats/BeamSpot/interface/BeamSpot.h"
#include "DataFormats/VertexReco/interface/Vertex.h"
#include "DataFormats/VertexReco/interface/VertexFwd.h"

#include "FWCore/ParameterSet/interface/ParameterSet.h"
#include "RecoMuon/MuonIdentification/plugins/ME0MuonSelector.cc"
#include "CommonTools/UtilAlgos/interface/TFileService.h"
#include "TFile.h"
#include "TH1F.h"
#include "TH2F.h"
#include "TTree.h"
#include <memory>
#include <vector>
#include <cmath>
#include "TLorentzVector.h"
//
// class declaration
//
using namespace std;
using namespace edm;
class ME0SegmentAnalyzer : public edm::EDAnalyzer {
public:
	explicit ME0SegmentAnalyzer(const edm::ParameterSet&);
	~ME0SegmentAnalyzer();
	void Initialize(); 
	
	static void fillDescriptions(edm::ConfigurationDescriptions& descriptions);
	
	
private:
	virtual void beginJob() override;
	virtual void analyze(const edm::Event&, const edm::EventSetup&) override;
	virtual void endJob() override;
	std::string wp_;
	double timeMin_;
	double timeMax_;
	double minEta_;
	double maxEta_;
	
	edm::Service<TFileService> fs;
	
	TH1F *hNEvZmm;  TH1F * hDPhi; TH1F *  hme0machtMuonPt;  TH1F *  hme0machtMuonEta;  TH1F *  hme0machtMuonPhi;  TH1F *  hme0machtMuonCharge;
	TH1F *  hNME0Time ;  TH1F *  hNME0RecHits; TH1F *  hPtRes ;  
	TH1F *  hSimPt; TH1F *  hSimEta;
	TH1F *  hNzmm;  TH1F *  hNEv;  TH1F *hNGenMu;  TH1F * hNME0Mu;  TH1F *   hNMatchME0Mu;
	
	TH2F *  hPtVSDphi;TH2F *  hPtVSDEta; TH2F *  hPVSDphi ;  TH2F *   hPtVSDX;  TH2F *   hPtVSDY;  TH2F *   hPtVSDXLocal;  TH2F *   hPtVSDYLocal; TH2F *  hPtResVSDPhi;TH2F *   hSimPtVSDphi;  
	
	
	TH1F *   hGenMuPt; TH1F *   hGenMuEta;
	TH1F *   hNumTight_Pt; TH1F *   hNumTight_Eta; TH1F *   hNumLoose_Pt; TH1F *   hNumLoose_Eta; TH1F *   hNumNoID_Eta; TH1F *   hNumNoID_Pt; 
	TH1F * hAbsDPhi ; TH1F * hAbsDEta;  TH1F * hDEta;TH1F * hDX;
	TH1F *   hGenMass;  TH1F *   hRecoMass; TH1F *   hRecoMassIntime;	TH1F * 	hRecoMass_matchID;
	
	TH2F * hSimPtVSDeta;
	TH1F *   hSimDEta;
	TH1F *   hSimDPhi; TH1F *   hSimDX; TH1F *   hSimDY;
	
	TH1F * hSelectedSimTrack;
	TH1F * hGenMuonsME0;
	TH1F * hME0MuonsID; TH1F * hME0MuonsInMatchCone;
	
	TH1F * hNSimHitsME0;
	TH1F * hNRecHitsME0;
	TH1F * hRatioRecoToSimHits;
	TH1F * hNME0Segment;
	TH1F * hNBkgHitsME0;
	TH1F * hRecHitTime;
	
	TH1F * hNDigiMatchedRH;	TH1F * hNPrompt;	TH1F * hN_noPrompt; TH1F * 	hNPromptMuHit;	TH1F * 	hNPromptNoMuHit;	TH1F * 	hNPromptHit_pdgId;	TH1F *  hME0SimTrackPdgID;	
	TH1F *  hSimElePtME0;TH1F *   hSimMuPtME0;	TH1F *   hSimPionPtME0;	TH1F * 	hSimEleNHitsME0;	TH1F * 	hSimMuonNHitsME0;	TH1F * 	hSimPionNHitsME0; TH1F * hPdgIDCheck; 
	TH2F *  hMuonDigiDPhiVsPT; TH2F * hNoEleDigiDPhiVsPT;
	
	TH1F * hDRME0SimTrack;	TH1F * hDRME0SimMuonEle;	TH1F * hN_noEleHit;	TH1F * hN_noPromptHit_pdgId;	TH1F *	hSegmentComposition;	TH1F * hNME0SegmentAfterDigiMatch;	TH1F * hMuEleinME0Segm;	TH1F * hMuEleOthersinME0Segm;TH1F * hMuOnlyinME0Segm;
	
	TH1F * hNEleBrem;	TH1F * hNEleDeltaRays;	TH1F * hNEle; TH1F * hMatchedSimEleTrack;
	
	TH1F * hRHDeltaPhiSameLayer;	TH1F * hRHDeltaEtaSameLayer;	TH1F * hRHDeltaTSameLayer;
	
	TH1F * hNoPromptRecHitTime;	TH1F * hMuonRecHitTime;	TH1F * hEleRecHitTime;	TH1F * hNMuonSameLayerTOF;	TH1F * hNEleSameLayerTOF;	TH1F * hNoPromptSameLayerTOF;
	
	TH1F * hDeltaPhiSimReco;	TH1F * hDeltaEtaSimReco;TH1F * hDeltaXSimReco; TH1F * hDeltaYSimReco; 
	TH1F * hNoMuinME0Segm; TH2F * hMuonDigiDXVsPT;	TH2F * hMuonDigiLocalDPhiVsPT; 	TH2F * hMuonDigiLocalDXVsPT; TH1F * hDeltaXSimRecoLocal; TH1F * hDeltaYSimRecoLocal;
	
	TH1F * 	hBeamSpotX0; 	TH1F * 	hBeamSpotY0; 	TH2F * 	hBeamSpotX0Y0;	TH1F * 	hBeamSpotZ0; 	TH1F * 	hBeamSpotSigmaZ;
	TH1F * 	hBeamSpotdxdz;	TH1F * 	hBeamSpotBeamWidthX;	TH1F * 	hBeamSpotBeamWidthY;	TH1F * 	hVertexMult ; 	TH1F * 	hverteX;	TH1F * 	hverteY;TH2F * 	hverteXY; TH1F * 	hverteZ ;
	
	TH2F * 	hRecDPhiVSimDphi;TH1F * hDiffRecDPhiVSimDphi;
	// virtual void beginRun(edm::Run const&, edm::EventSetup const&) override;
	//virtual void endRun(edm::Run const&, edm::EventSetup const&) override;
	//virtual void beginLuminosityBlock(edm::LuminosityBlock const&, edm::EventSetup const&) override;
	//virtual void endLuminosityBlock(edm::LuminosityBlock const&, edm::EventSetup const&) override;
	
	// ----------member data ---------------------------
};

//
// constants, enums and typedefs
//

//
// static data member definitions
//

//
// constructors and destructor
//
ME0SegmentAnalyzer::ME0SegmentAnalyzer(const edm::ParameterSet& iConfig):
wp_(iConfig.getParameter<std::string>("wp")),
timeMin_(iConfig.getParameter<double>("timeMin")),
timeMax_(iConfig.getParameter<double>("timeMax")),
minEta_(iConfig.getParameter<double>("minEta")),
maxEta_(iConfig.getParameter<double>("maxEta"))

{
	
}


ME0SegmentAnalyzer::~ME0SegmentAnalyzer()
{
	
	// do anything here that needs to be done at desctruction time
	// (e.g. close files, deallocate resources etc.)
	
}

bool isSimMatched(edm::SimTrackContainer::const_iterator simTrack, edm::PSimHitContainer::const_iterator itHit)
{
	
	bool result = false;
	
	int trackId = simTrack->trackId();
	int trackId_sim = itHit->trackId();
	if(trackId == trackId_sim) result = true;
	
	//std::cout<<"ID: "<<trackId<<" "<<trackId_sim<<" "<<result<<std::endl;
	
	
	
	return result;
	
}


edm::PSimHitContainer isTrackMatched(SimTrackContainer::const_iterator simTrack, const Event & event, const EventSetup& eventSetup)
{
	edm::PSimHitContainer selectedME0Hits;
	
	edm::ESHandle<ME0Geometry> me0geom;
	eventSetup.get<MuonGeometryRecord>().get(me0geom);
	
	edm::Handle<edm::PSimHitContainer> ME0Hits;
	event.getByLabel(edm::InputTag("g4SimHits","MuonME0Hits"), ME0Hits);
	
	ESHandle<GlobalTrackingGeometry> theTrackingGeometry;
	eventSetup.get<GlobalTrackingGeometryRecord>().get(theTrackingGeometry);
	
	for (edm::PSimHitContainer::const_iterator itHit =  ME0Hits->begin(); itHit != ME0Hits->end(); ++itHit){
		
		DetId id = DetId(itHit->detUnitId());
		if (!(id.subdetId() == MuonSubdetId::ME0)) continue;
		if(itHit->particleType() != (*simTrack).type()) continue;
		
		bool result = isSimMatched(simTrack, itHit);
		if(result) selectedME0Hits.push_back(*itHit);
		
	}
	
	//	std::cout<<"N simHit in ME0segm : "<<selectedME0Hits.size()<<std::endl;
	return selectedME0Hits;
	
}

struct MyME0Digi
{
    Int_t detId, particleType;
    Short_t layer;
    Float_t g_eta, g_phi;
	Float_t tof;
	Float_t prompt;
};

void
ME0SegmentAnalyzer::analyze(const edm::Event& iEvent, const edm::EventSetup& iSetup)
{
	//Initialize();
	using namespace edm;
	
	edm::Handle<SimTrackContainer> simTracks;
	iEvent.getByLabel("g4SimHits",simTracks);
	
	edm::Handle <std::vector<reco::ME0Muon> > OurMuons;
	iEvent.getByLabel <std::vector<reco::ME0Muon> > ("me0SegmentMatching", OurMuons);
	
	edm::Handle<ME0SegmentCollection> me0Segments;
	iEvent.getByLabel("me0Segments", me0Segments);
	
	edm::Handle <reco::GenParticleCollection> genparticles;
	iEvent.getByLabel("genParticles",genparticles);
	
	edm::Handle <std::vector<reco::Muon> > muons;    
	iEvent.getByLabel("muons", muons ); 
	
	edm::Handle<ME0DigiPreRecoCollection> me0_digis;
	iEvent.getByLabel("simMuonME0Digis",  me0_digis); 
	
	reco::BeamSpot beamSpot;
	edm::Handle<reco::BeamSpot> beamSpotHandle;
	iEvent.getByLabel("offlineBeamSpot", beamSpotHandle);
	
	edm::Handle<reco::VertexCollection> primaryVertices;
	iEvent.getByLabel("offlinePrimaryVertices", primaryVertices);

	edm::Handle<edm::PSimHitContainer>  ME0HitsCollection;
	iEvent.getByLabel(edm::InputTag("g4SimHits","MuonME0Hits"), ME0HitsCollection);
	
	edm::ESHandle<ME0Geometry> me0geom;
	iSetup.get<MuonGeometryRecord>().get(me0geom);
	const ME0Geometry* me0Geom;
	me0Geom= &*me0geom;
	
	
	/*
	 Run   = iEvent.id().run();
	 Event = iEvent.id().event();
	 Lumi  = iEvent.luminosityBlock();
	 Bunch = iEvent.bunchCrossing();
	 */
	
	std::cout<<"********************************************BeginEvent="<<iEvent.id().event()<<"******************************************** "<<std::endl;
	std::vector<int> indexgenmu;
	hNEv->Fill(1);  
	
	//if(( iEvent.id().run()==1381 &&  iEvent.luminosityBlock()==277)) {
	///////////////////////////////////////////////////////////////////////////////////////////////////Loop over simTracks//////////////////////////////////////////////////////////////////////////////////////////
	//	std::cout<<" me0DigiSize="<<me0_digis->size()<<std::endl;
	
	
	SimTrackContainer::const_iterator simTrack;
	double numberOfSimTracks =0.;
	//std::cout<<" num Simulated tracks: "<<simTracks->size()<<std::endl;
	std::vector<double> simHitPhi, simHitElePhi, simHitX;
	std::vector<double> simHitEta, simHitEleEta, simHitY;
	std::vector<int> numME0SimHits;
	SimTrackContainer ME0Tracks, ME0EleSimTracks;
	for (simTrack = simTracks->begin(); simTrack != simTracks->end(); ++simTrack){
		
		
		//if ((*simTrack).noVertex()) continue;
		if ((*simTrack).noGenpart()) continue;
		if (!(abs((*simTrack).type()) == 13)) continue;
		
		//cout<<"Sim pT: "<<(*simTrack).momentum().pt()<<endl;
		double simPt=(*simTrack).momentum().pt();
		
		//cout<<"Sim Eta: "<<(*simTrack).momentum().eta()<<endl;
		double simEta = (*simTrack).momentum().eta();
		
		//cout<<"Sim Phi: "<<(*simTrack).momentum().phi()<<endl;
		//double simPhi = (*simTrack).momentum().phi();
		
		if (abs(simEta) > maxEta_ || abs(simEta) < minEta_) continue;
		
		
		if (fabs((*simTrack).type())==11)	{hSimElePtME0->Fill(simPt);	 ME0EleSimTracks.push_back(*simTrack);}
		if (fabs((*simTrack).type())==13)	{hSimMuPtME0->Fill(simPt); }
		if (fabs((*simTrack).type())==211)	{hSimPionPtME0->Fill(simPt); } 
		hME0SimTrackPdgID->Fill( fabs((*simTrack).type()) );
		
		edm::PSimHitContainer selME0SimHits = isTrackMatched(simTrack, iEvent , iSetup);
		
		//int ME0SimHitsize = selME0SimHits.size();
		//std::cout<<"# me0 sim hits="<< selME0SimHits.size() <<std::endl;
		
		if( selME0SimHits.size() ==0 ) continue;
		
		
		hSimEta->Fill((*simTrack).momentum().eta());
		hSimPt->Fill((*simTrack).momentum().pt());
			
		ME0Tracks.push_back(*simTrack);
		numberOfSimTracks++;
		//std::cout<<"TrackID="<<simTrack->trackId()<<" track type="<<(*simTrack).type()<<"# me0 sim hits="<< selME0SimHits.size() <<" simPt="<<simPt<<std::endl;
		simHitPhi.clear(); simHitEta.clear();
		simHitX.clear();   simHitY.clear();
		int selhitcounter =0;
	
		for (edm::PSimHitContainer::const_iterator itHit =  selME0SimHits.begin(); itHit != selME0SimHits.end(); ++itHit){
			//ME0DetId idme0 = ME0DetId(itHit->detUnitId());	
			//int layer_sim = idme0.layer();		
			LocalPoint lp = itHit->entryPoint();
			GlobalPoint hitGP_sim( me0geom->idToDet(itHit->detUnitId())->surface().toGlobal(lp));		
			simHitPhi.push_back(hitGP_sim.phi());
			simHitEta.push_back(hitGP_sim.eta());
			simHitX.push_back(hitGP_sim.x());
			simHitY.push_back(hitGP_sim.y());
			selhitcounter	++;
			//std::cout<<" simHit eta="<<hitGP_sim.eta()<<" phi="<<hitGP_sim.phi()<<" simHit detID="<<idme0<<" layer sim="<<layer_sim<<" X="<<hitGP_sim.x()<<" trackID="<<itHit->trackId()<<std::endl;
		}
		numME0SimHits.push_back(selhitcounter);
		int sizeSimPhi = simHitPhi.size()-1;
		double SimDeltaPhi = TMath::Abs( simHitPhi[0] - simHitPhi[sizeSimPhi] );
		double SimDeltaEta= TMath::Abs( simHitEta[0] - simHitEta[sizeSimPhi] );
	     
		cout<<"Track:"<<simTrack->trackId()<<" pdgID="<<(*simTrack).type()<<" SimDPhi="<<simHitPhi[0] - simHitPhi[sizeSimPhi]<<" pT="<<simPt<<endl;
		
		
			hSimPtVSDphi->Fill(SimDeltaPhi, simPt);
			hSimPtVSDeta->Fill(SimDeltaEta, simPt);
			hSimDEta->Fill( simHitEta[0] - simHitEta[sizeSimPhi]);
			hSimDPhi->Fill( simHitPhi[0] - simHitPhi[sizeSimPhi]);
			hSimDX->Fill( simHitX[0] - simHitX[sizeSimPhi]);
			hSimDY->Fill( simHitY[0] - simHitX[sizeSimPhi]);
	
		
	}
//	std::cout<<" Num simTrack in ME0  "<<numberOfSimTracks<<" ME0Track.size()="<<ME0Tracks.size()<<" Num me0 segm="<<me0Segments->size()<<std::endl;
	if (ME0Tracks.size()>0) hSelectedSimTrack->Fill(ME0Tracks.size());
	if (me0Segments->size()>0) hNME0Segment->Fill(me0Segments->size());
	
/*	
	for(uint k=0; k<ME0Tracks.size(); k++){
		//	if( fabs(ME0Tracks.at(k).type())==11) ME0SimTracksEle.push_back(ME0Tracks.at(k));
		
		for(uint r=k+1; r<ME0Tracks.size(); r++){
			double DRSimTrack=TMath::Sqrt( (ME0Tracks.at(k).momentum().eta() - ME0Tracks.at(r).momentum().eta())*(ME0Tracks.at(k).momentum().eta() - ME0Tracks.at(r).momentum().eta()) + (ME0Tracks.at(k).momentum().phi() - ME0Tracks.at(r).momentum().phi())*(ME0Tracks.at(k).momentum().phi() - ME0Tracks.at(r).momentum().phi()) ) ;
			hDRME0SimTrack->Fill(DRSimTrack);
			if((fabs(ME0Tracks.at(k).type())==13 && fabs(ME0Tracks.at(r).type())==11) || (fabs(ME0Tracks.at(r).type())==13 && fabs(ME0Tracks.at(k).type())==11)) {
				//std::cout<<" me0Track="<<k<<" pdgID="<<ME0Tracks.at(k).type()<<" me0Track="<<r<<" pdgID="<<ME0Tracks.at(r).type()<<" DR="<<DRSimTrack<<std::endl;
				hDRME0SimMuonEle->Fill(DRSimTrack);
			}
		}
	}
 */
	///////////////////////////////////////////////////////////////////////////////////////////////////Loop over simTracks//////////////////////////////////////////////////////////////////////////////////////////
	/*
	SimTrackContainer::const_iterator simTrackIT;
	for(simTrackIT=ME0Tracks.begin() ; simTrackIT <ME0Tracks.end(); simTrackIT++){
		
		cout<<"ME0SimTrack Eta: "<<(*simTrackIT).momentum().eta()<<endl;
		//double simEta = (ME0Tracks.at(k)).momentum().eta();
		
		//cout<<"Sim Phi: "<<(*simTrack).momentum().phi()<<endl;
		//double simPhi = (*simTrack).momentum().phi();
		
	
	}
	*/
	//////////////////////////////////////////////////////////////////////////////////////////Loop over gen particles//////////////////////////////////////////////////////////////////////////////////////////
	
	
	for(unsigned int i = 0; i < genparticles->size();i++) {
		if((abs(genparticles->at(i).pdgId()) == 13) && (genparticles->at(i).status() == 1) && (genparticles->at(i).numberOfMothers() > 0)) {
			
			if(fabs(genparticles->at(i).mother()->pdgId()) == 23) {
				indexgenmu.push_back(i); 
				
			}
			else if(abs(genparticles->at(i).pdgId()) == abs(genparticles->at(i).mother()->pdgId())) {
				
				if(genparticles->at(i).mother()->numberOfMothers() > 0) {
					
					if(abs(genparticles->at(i).mother()->mother()->pdgId()) == 23) {
					indexgenmu.push_back(i); }
				}
				
				if(genparticles->at(i).mother()->mother()->numberOfMothers() > 0) {
					
					if(abs(genparticles->at(i).mother()->mother()->mother()->pdgId()) == 23) {
					indexgenmu.push_back(i);}
				}
				
				if(genparticles->at(i).mother()->mother()->mother()->numberOfMothers() > 0) {
					
					if(abs(genparticles->at(i).mother()->mother()->mother()->mother()->pdgId()) == 23 || fabs(genparticles->at(i).mother()->pdgId()) == 22) {
					indexgenmu.push_back(i);}
					
				}
			}//genealogia
		}//mu status 1
	}//filtro eventi
	
//	std::cout<< "N gen muon " << indexgenmu.size() << " N me0 muon " << OurMuons->size() << std::endl;
	
	
	int counterZmm =0;
	if (indexgenmu.size()>0) {counterZmm ++; hNzmm->Fill(1);}
	
	std::vector<int>  indexGenMuInME0;
	std::vector<int>  indexGenMuElseWhere;
	std::vector<int>  indexRecoMuElseWhere;
	TLorentzVector genmu1, genmu2, genZ;
	TLorentzVector recomu1, recomu2, recoZ;
	TLorentzVector recomu1Intime, recomu2Intime, recoZIntime;
	
	
	for(uint i =0; i<indexgenmu.size(); i++){
		std::cout<<i<<" particle= "<<genparticles->at(indexgenmu[i]).pdgId()<<" status="<<genparticles->at(indexgenmu[i]).status()<<" eta="<<genparticles->at(indexgenmu[i]).eta()<<" phi="<<genparticles->at(indexgenmu[i]).phi()<<" pt="<<genparticles->at(indexgenmu[i]).pt()<<std::endl;
		hGenMuPt->Fill( (genparticles->at(indexgenmu[i]).pt()));
		hGenMuEta->Fill( (genparticles->at(indexgenmu[i]).eta())  );
		
		if ( indexgenmu.size() ==2){
			genmu1.SetPtEtaPhiM(genparticles->at(indexgenmu[0]).pt(),genparticles->at(indexgenmu[0]).eta(), genparticles->at(indexgenmu[0]).phi(), 0.105   );
			genmu2.SetPtEtaPhiM(genparticles->at(indexgenmu[1]).pt(),genparticles->at(indexgenmu[1]).eta(), genparticles->at(indexgenmu[1]).phi(), 0.105   );
			genZ = genmu1 +genmu2;
			//std::cout<<" gen pt1="<<genmu1.Pt()<<" eta="<<genmu1.Eta()<<std::endl;
			//std::cout<<" gen pt2="<<genmu2.Pt()<<" eta="<<genmu2.Eta()<<std::endl;
			hGenMass->Fill(genZ.M());
		}
		
		if((abs(genparticles->at(indexgenmu[i]).eta())<maxEta_ ) && ( (genparticles->at(indexgenmu[i]).eta() > minEta_ )||(genparticles->at(indexgenmu[i]).eta()< (-minEta_ )) )  ){
			indexGenMuInME0.push_back(indexgenmu[i]);
			//std::cout<<i<<" particle= "<<genparticles->at(indexgenmu[i]).pdgId()<<" status="<<genparticles->at(indexgenmu[i]).status()<<" eta="<<genparticles->at(indexgenmu[i]).eta()<<" phi="<<genparticles->at(indexgenmu[i]).phi()<<" pt="<<genparticles->at(indexgenmu[i]).pt()<<std::endl;
			}else{
			indexGenMuElseWhere.push_back(indexgenmu[i]);
			}
	}
	
	hGenMuonsME0->Fill(indexGenMuInME0.size());
	hNGenMu->Fill(indexgenmu.size());
	hNME0Mu->Fill(OurMuons->size());
	
	//std::cout<< "N gen muon in me0 " << indexGenMuInME0.size() <<""<< std::endl;
	unsigned int k = 0;
	std::vector<double>   me0SegAbsDPhi;  std::vector<double>   me0SegDPhi;
	std::vector<double>   me0SegAbsDEta;  std::vector<double>   me0SegDEta;
	std::vector<int>  idxtmpreco;
	std::vector<uint>  idxtmpgen;
	//find all the me0 muon next to the genMuon in DR<0.1
	for ( std::vector<reco::ME0Muon>::const_iterator thisMuon = OurMuons->begin(); thisMuon != OurMuons->end(); ++thisMuon, ++k){
		
		for(unsigned int i = 0; i<indexGenMuInME0.size(); i++){
			int m =indexGenMuInME0.at(i);
			// std::cout<<i<<" particle= "<<genparticles->at(m).pdgId()<<" status="<<genparticles->at(m).status()<<"  pt= "<<genparticles->at(m).pt()<<" eta="<<genparticles->at(m).eta()<<std::endl;
			double dr= reco::deltaR(genparticles->at(m),*thisMuon);
			if(dr < 0.25) {
				idxtmpreco.push_back(k);
				idxtmpgen.push_back(m);
				// std::cout<<" DR genmu, me0mu "<< dr <<std::endl;
			}
			
		}//dr gen particle
		
	}//me0muon loop
	
	hME0MuonsInMatchCone->Fill(idxtmpreco.size());
	//std::cout<<" genmu in matching cone   "<<indexgenmu.size()<<" recomu in matching cone  "<<idxtmpreco.size()<<std::endl;
	
	//find the nearest me0 muon to the genMu and double-check that dist<0.1
	std::vector<int> minDRgen;
	std::vector<int> minDRreco;
	std::vector<int> bkgidx;
	for(uint k =0; k<indexgenmu.size(); k++){
		double drprova = 5;
		int idxprovagen =-99;
		int idxprovareco =-99;
		
		for(uint i =0; i<idxtmpreco.size(); i++){
			double drnew= reco::deltaR(genparticles->at(indexgenmu[k]),OurMuons->at(idxtmpreco[i]));
			//std::cout<<"gen idx="<<indexgenmu.at(k)<<"  reco idx="<<idxtmpreco.at(i)<<" DR matched mu  "<<drnew<<std::endl;
			if(drnew<drprova){
				drprova = drnew;
				idxprovagen = indexgenmu.at(k);
				idxprovareco = idxtmpreco.at(i);
				//std::cout<<" drprova "<<drprova<<" idx reco "<<idxprovareco<<"  idxgen "<<idxprovagen<<std::endl;
				
			}
		}
		//std::cout<<" DR MINIMO DELLE MIE PALLE "<< drprova<<" idx gen "<<idxprovagen<<" idx reco  "<<idxprovareco<<std::endl;
		if(drprova<0.25){
			minDRreco.push_back(idxprovareco);
			minDRgen.push_back(idxprovagen);
		}
		
	}	    
	
	
	///verify matched muons with minDR
	//std::cout<<"N me0 matched muon " <<  minDRreco.size() << std::endl;
	hNMatchME0Mu->Fill(minDRreco.size());
	
	////////////////////////////////////////////////////////////////Loop on me0 matched muons////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	std::vector<int> idxMatchME0id;
	std::vector<int> numME0RecHits;
	//int m=0;
	std::vector<MyME0Digi> me0DigiVector;
	for(unsigned int m=0;m< minDRreco.size();m++ ){
	//for ( std::vector<reco::ME0Muon>::const_iterator thisMuon = OurMuons->begin(); thisMuon != OurMuons->end(); ++thisMuon, ++m){
	
		int me0idx = m;
		
		//std::cout<<"beforeID: me0Muon pt="<<OurMuons->at(me0idx).pt()<<" me0MuonEta="<<OurMuons->at(me0idx).eta()<<" LOOSE="<<muon::isGoodMuon(me0geom, OurMuons->at(me0idx), muon::Loose)<<" Tight="<<muon::isGoodMuon(me0geom, OurMuons->at(me0idx), muon::Tight)<<std::endl;
		bool isLoose = muon::isGoodMuon(me0geom, OurMuons->at(me0idx), muon::Loose);
		bool isTight = muon::isGoodMuon(me0geom, OurMuons->at(me0idx), muon::Tight);
		
		bool IDwp =   (wp_ == "loose") ? isLoose : isTight;
		
		if (!IDwp) continue;
		idxMatchME0id.push_back(me0idx);
		
		//	std::cout<<"AfterID: me0Muon pt="<<OurMuons->at(me0idx).pt()<<" me0MuonEta"<<OurMuons->at(me0idx).eta()<<" ID"<<std::endl;
		
		hme0machtMuonPt->Fill(OurMuons->at(me0idx).pt());	
		hme0machtMuonEta->Fill(OurMuons->at(me0idx).eta());	
		hme0machtMuonPhi->Fill(OurMuons->at(me0idx).phi());	
		hme0machtMuonCharge->Fill(OurMuons->at(me0idx).charge());	
		//int SegId=OurMuons->at(me0idx).me0segid();
		std::cout<<" me0muon pt="<<OurMuons->at(me0idx).pt()<<" me0 mu eta "<<OurMuons->at(me0idx).eta()<<std::endl;
		//ME0DetId id = (OurMuons->at(me0idx).me0segment()).me0DetId();
		//std::cout <<" Original ME0DetID "<<id<<std::endl;
		auto me0rhs =  (OurMuons->at(me0idx).me0segment()).specificRecHits();
		
		hNME0Time->Fill((OurMuons->at(me0idx).me0segment()).time());
		hNME0RecHits->Fill(me0rhs.size());
		//numME0RecHits.push_back(me0rhs.size());
		std::vector<double> PhiSimMuonForCheck;
		
	
		for(uint r=0; r<ME0Tracks.size(); r++){
			double DRSimTrackME0Muon=TMath::Sqrt( (ME0Tracks.at(r).momentum().eta() - OurMuons->at(me0idx).eta())*(ME0Tracks.at(r).momentum().eta() - OurMuons->at(me0idx).eta()) +
												 (ME0Tracks.at(r).momentum().phi() - OurMuons->at(me0idx).phi())*( ME0Tracks.at(r).momentum().phi() - OurMuons->at(me0idx).phi()) )  ;
			
			if(DRSimTrackME0Muon<0.3){			
				PhiSimMuonForCheck.clear();
				for (edm::PSimHitContainer::const_iterator itHit =  ME0HitsCollection->begin(); itHit != ME0HitsCollection->end(); ++itHit){
					DetId id = DetId(itHit->detUnitId());		
					if( (itHit->trackId() == ME0Tracks.at(r).trackId()) && (id.subdetId() == MuonSubdetId::ME0))	{			
						
						//ME0DetId idme0 = ME0DetId(itHit->detUnitId());	
						//int layer_sim = idme0.layer();		
						LocalPoint lp = itHit->entryPoint();
						GlobalPoint hitGP_sim( me0geom->idToDet(itHit->detUnitId())->surface().toGlobal(lp));		
						PhiSimMuonForCheck.push_back(hitGP_sim.phi());
						//std::cout<<"SimPhi="<<hitGP_sim.phi()<<std::endl;		
					}}
				
			    //cout<<"CHECK Track:"<< ME0Tracks.at(r).trackId()<<" pdgID="<< ME0Tracks.at(r).type()<<" SimDPhi="<<(PhiSimMuonForCheck[0] - PhiSimMuonForCheck[PhiSimMuonForCheck.size()-1])<<" pT="<<ME0Tracks.at(r).momentum().pt()<<endl;
			}
		}
		
		
		//for each segment, loop over the rechits
		int  hitCounter=0;
		std::vector<double>   me0RHPhi;
		std::vector<double>   me0RHEta;
		std::vector<double>   me0RHX;
		std::vector<double>   me0RHY;
		std::vector<double>   me0RHXlocal;
		std::vector<double>   me0RHYlocal;
		std::vector<double>   me0RHPhiMuonOnly, me0RHPhiNoEle, ME0SegmDIGIMatchedEta, ME0SegmDIGIMatchedPhi,    me0RHXMuonOnly, me0RHLocalXMuonOnly, me0RHLocalPhiMuonOnly;
		std::vector<int> Nrechit; 
		std::vector<int> NPromptHit; 
		std::vector<int> N_noPromptHit; 
		std::vector<int> NBkgHit; 
		std::vector<int> NPromptMuHit, N_noEleHit;
		std::vector<int> NPromptNoMuHit, NPromptNoMuHit_pdgId, NMuAllHit, NEleAllHit , NOtherAllHit;
		
		MyME0Digi me0Digi_tmp;
		me0DigiVector.clear();
		for (auto rh = me0rhs.begin(); rh!= me0rhs.end(); rh++){
			
			hitCounter++;
			auto rhLP = rh->localPosition();
			double localX = rhLP.x();
			double localY = rhLP.y();
			
			auto me0id = rh->me0Id();
			
			auto rhr = me0Geom->etaPartition(me0id);
			auto rhGP = rhr->toGlobal(rhLP);
			double globalEta = rhGP.eta();
			double globalPhi = rhGP.phi();
			double globalX = rhGP.x();
			double globalY = rhGP.y();
			
			
			//auto rhtime = rh->TOF();
			//std::cout<< hitCounter<<" rechit global phi="<< globalPhi<<" global eta="<<globalEta<<" global x="<<globalX<<" global Y="<<globalY<<" tof="<<rh->tof()<<" rechit layer "<< me0id.layer()<<std::endl;
			
			
			//std::cout<< hitCounter<<" rechit local  x="<< rhLP.x() <<" local y="<< rhLP.y()<<"layer  "<< me0id.layer()<<<std::endl;
			me0RHPhi.push_back(globalPhi);
			me0RHEta.push_back(globalEta);
			
			me0RHX.push_back(globalX);
			me0RHY.push_back(globalY);
			
			me0RHXlocal.push_back(localX);
			me0RHYlocal.push_back(localY);
			//hRecHitTime->Fill(rh->tof());
			
			
			for(ME0DigiPreRecoCollection::DigiRangeIterator cItr = me0_digis->begin(); cItr != me0_digis->end(); ++cItr){
				
				ME0DetId id = (*cItr).first;
				Short_t  me0_digiLayer =  id.layer();
				
				const GeomDet* gdet = me0Geom->idToDet(id);
				const BoundPlane & surface = gdet->surface();
				
				ME0DigiPreRecoCollection::const_iterator digiItr;
				for (digiItr = (*cItr ).second.first; digiItr != (*cItr ).second.second; ++digiItr)
				{
					
					LocalPoint lp(digiItr->x(), digiItr->y(), 0);
					GlobalPoint gp = surface.toGlobal(lp);
					Float_t me0_digiEta = gp.eta();
					Float_t me0_digiPhi = gp.phi();
					Float_t me0_digiX = gp.x();
					Float_t me0_digiY = gp.y();
					Float_t me0_digiLocalX= lp.x();
					Float_t me0_digiLocalY= lp.y();
					Float_t me0_digiLocalPhi= lp.phi();
					
					if(globalX == me0_digiX && globalY == me0_digiY && me0_digiLayer==me0id.layer()){ 
						//std::cout<<" DIGI global phi "<<me0_digiPhi<<" global eta "<<me0_digiEta<<" global X "<< me0_digiX << " global Y "<< me0_digiY  <<" layer "<<me0_digiLayer<<" pdg="<<digiItr->pdgid()<<" is prompt? "<<digiItr->prompt()<<"  tof="<<digiItr->tof()<<std::endl;
						me0Digi_tmp.particleType=digiItr->pdgid();
						me0Digi_tmp.layer =me0_digiLayer;
						me0Digi_tmp.g_eta=me0_digiEta;
						me0Digi_tmp.g_phi=me0_digiPhi;
						me0Digi_tmp.tof=digiItr->tof();
						me0Digi_tmp.prompt=digiItr->prompt();
						me0DigiVector.push_back(me0Digi_tmp);
						
						Nrechit.push_back(1);
						
						
				
							for (SimTrackContainer::const_iterator me0it = ME0Tracks.begin(); me0it  != ME0Tracks.end(); ++me0it ){
													
								edm::PSimHitContainer selME0EleSimHits = isTrackMatched(me0it, iEvent , iSetup);
								if(selME0EleSimHits.size()==0) continue;
								
								//std::cout<<"######## ELEME0 TrackType= "<<me0it->type()<<" id="<<me0it->trackId()<<std::endl;
								//ME0SegmDIGIMatchedEta.clear(); ME0SegmDIGIMatchedPhi.clear();
								//if(!(fabs(me0it->type())==11))continue;
								for (edm::PSimHitContainer::const_iterator itHit =  selME0EleSimHits.begin(); itHit != selME0EleSimHits .end(); ++itHit){
									ME0DetId idme0 = ME0DetId(itHit->detUnitId());	
									int layer_sim = idme0.layer();		
									LocalPoint lp = itHit->entryPoint();
									GlobalPoint hitGP_sim( me0geom->idToDet( itHit->detUnitId())->surface().toGlobal(lp));	
									
									if( (fabs(me0it->type())==13) && (fabs(digiItr->pdgid())==13) && (me0it->type()==digiItr->pdgid()) && (layer_sim==me0_digiLayer) && (digiItr->prompt()) ){
										//std::cout<<"####### SimHit eta="<<hitGP_sim.eta()<<" phi="<<hitGP_sim.phi()<<" layer="<<layer_sim<<" X="<<hitGP_sim.x()<<" type="<<itHit->particleType()<<" trackID="<<itHit->trackId()<<std::endl;																			
								        //std::cout<<"####### DIGI   eta="<<me0_digiEta<<" phi="<<me0_digiPhi<<" layer="<<me0_digiLayer<<" X="<<me0_digiX<<" Y="<<me0_digiY<<" pdg="<<digiItr->pdgid()<<std::endl;
										//std::cout<<"####### DIGI x="<<me0_digiX<<" X="<<hitGP_sim.x()<<" diff="<<hitGP_sim.x()-me0_digiX<<" reco localX="<<me0_digiLocalX<<" sim LocalX="<<lp.x()<<std::endl;
										std::cout<<"####### DIGI DPhi(SimHit, RecHit)="<<hitGP_sim.phi()-me0_digiPhi<<endl;
										hDeltaPhiSimReco->Fill(hitGP_sim.phi()-me0_digiPhi);
										hDeltaEtaSimReco->Fill(hitGP_sim.eta()-me0_digiEta);
										hDeltaXSimReco->Fill(hitGP_sim.x()-me0_digiX);
										hDeltaYSimReco->Fill(hitGP_sim.y()-me0_digiY);
										hDeltaXSimRecoLocal->Fill(lp.x()-me0_digiLocalX);
										hDeltaYSimRecoLocal->Fill(lp.y()-me0_digiLocalY);
										//PhiSimMuonForCheck.push_back(hitGP_sim.phi());
									}
									
								//	std::cout<<"####### DeltaPhiSimTrack="<<PhiSimMuonForCheck[0]-PhiSimMuonForCheck[PhiSimMuonForCheck.size()]<<endl;
									
									if(digiItr->pdgid() == itHit->particleType() == 11){
										if((fabs(hitGP_sim.eta()-me0_digiEta)<3*0.01) && (fabs(hitGP_sim.phi()-me0_digiPhi)<3*0.05)  && (me0_digiLayer==layer_sim) )
										//std::cout<<"####### simHit eta="<<hitGP_sim.eta()<<" phi="<<hitGP_sim.phi()<<" simHit detID="<<idme0<<" layer sim="<<layer_sim<<" X="<<hitGP_sim.x()<<" trackID="<<itHit->trackId()<<" type="<<itHit->particleType()<<std::endl;																			
										//std::cout<<"#######DIGI global phi "<<me0_digiPhi<<" global eta "<<me0_digiEta<<" global X "<< me0_digiX << " global Y "<< me0_digiY  <<" layer "<<me0_digiLayer<<" pdg="<<digiItr->pdgid()<<" is prompt? "<<digiItr->prompt()<<"  tof="<<digiItr->tof()<<std::endl;
										//std::cout<<"#######DigiPhi="<<me0_digiPhi<<" SimPhi="<<hitGP_sim.phi()<<std::endl;
										ME0SegmDIGIMatchedEta.push_back(me0_digiEta);
										ME0SegmDIGIMatchedPhi.push_back(me0_digiPhi);
									}
									
								}
								if(ME0SegmDIGIMatchedPhi.size()>0) hMatchedSimEleTrack->Fill((*me0it).momentum().pt());
							}
						//}
						
						
						if(TMath::Abs( digiItr->pdgid())==13) NMuAllHit.push_back(1);
						if(TMath::Abs( digiItr->pdgid())==11) NEleAllHit.push_back(1);
						if(TMath::Abs( digiItr->pdgid())>200) NOtherAllHit.push_back(1);
						
						if(digiItr->prompt()==0){ 
							N_noPromptHit.push_back(1);
							hN_noPromptHit_pdgId->Fill(digiItr->pdgid()); 
							hNoPromptRecHitTime->Fill(digiItr->tof());
						}
						if(digiItr->prompt()==1){
							NPromptHit.push_back(1);
							hNPromptHit_pdgId->Fill(fabs(digiItr->pdgid()));
							if(TMath::Abs( digiItr->pdgid())==13){
								NPromptMuHit.push_back(1); 
								me0RHPhiMuonOnly.push_back(me0_digiPhi);
								me0RHXMuonOnly.push_back(me0_digiX);
								
								me0RHLocalPhiMuonOnly.push_back(me0_digiLocalPhi);
								me0RHLocalXMuonOnly.push_back(me0_digiLocalX);
								
								hMuonRecHitTime->Fill(digiItr->tof());
							}
							if(TMath::Abs( digiItr->pdgid())!=13) {
								NPromptNoMuHit.push_back(1);
								NPromptNoMuHit_pdgId.push_back(digiItr->pdgid());
							}
							if(TMath::Abs( digiItr->pdgid())==11) hEleRecHitTime->Fill(digiItr->tof());
							if(TMath::Abs( digiItr->pdgid())!=11){
								me0RHPhiNoEle.push_back(me0_digiPhi);
								hPdgIDCheck->Fill(digiItr->pdgid());
								N_noEleHit.push_back(1);
							}
						}
						
						
											
						
						
					}//DIGI MATCHED WITH RH
				}
			}//loop over digi			
		}//loop over rechit
		
		std::vector<int> NHitsSameLayer1,NHitsSameLayer2,NHitsSameLayer3,NHitsSameLayer4,NHitsSameLayer5,NHitsSameLayer6 ;
		//std::cout<<"---------digiVecSize "<<me0DigiVector.size()<<std::endl;
		for (uint l=0; l<me0DigiVector.size(); l++){
			for (uint k=l+1; k<me0DigiVector.size(); k++){
				if(me0DigiVector.at(l).layer == me0DigiVector.at(k).layer) {
					
					if(me0DigiVector.at(l).layer==1) NHitsSameLayer1.push_back(1);
					if(me0DigiVector.at(l).layer==2) NHitsSameLayer2.push_back(1);
					if(me0DigiVector.at(l).layer==3) NHitsSameLayer3.push_back(1);
					if(me0DigiVector.at(l).layer==4) NHitsSameLayer4.push_back(1);
					if(me0DigiVector.at(l).layer==5) NHitsSameLayer5.push_back(1);
					if(me0DigiVector.at(l).layer==6) NHitsSameLayer6.push_back(1);
					
					if(fabs(me0DigiVector.at(l).particleType)==13) hNMuonSameLayerTOF->Fill(me0DigiVector.at(l).tof);
					if(fabs(me0DigiVector.at(k).particleType)==13) hNMuonSameLayerTOF->Fill(me0DigiVector.at(k).tof);
					
					if(fabs(me0DigiVector.at(l).particleType)==11) hNEleSameLayerTOF->Fill(me0DigiVector.at(l).tof);
					if(fabs(me0DigiVector.at(k).particleType)==11) hNEleSameLayerTOF->Fill(me0DigiVector.at(k).tof);
					
					if(me0DigiVector.at(l).prompt==0) hNoPromptSameLayerTOF->Fill(me0DigiVector.at(l).tof);
					if(me0DigiVector.at(k).prompt==0) hNoPromptSameLayerTOF->Fill(me0DigiVector.at(k).tof);
					
					if((fabs(me0DigiVector.at(l).particleType)==13 && fabs(me0DigiVector.at(k).particleType)!=13) || (fabs(me0DigiVector.at(k).particleType)==13 && fabs(me0DigiVector.at(l).particleType)!=13)){
					//	std::cout<<l<<" "<<k<<"---digi1="<<me0DigiVector.at(l).particleType<<" digi2="<<me0DigiVector.at(k).particleType<<"  "<<me0DigiVector.at(l).g_phi<<"   "<<me0DigiVector.at(k).g_phi<<"  l1="<<me0DigiVector.at(l).layer<<" l2="<<me0DigiVector.at(k).layer<<" dist="<<me0DigiVector.at(l).g_phi - me0DigiVector.at(k).g_phi<<std::endl;
						hRHDeltaPhiSameLayer->Fill((me0DigiVector.at(l).g_phi - me0DigiVector.at(k).g_phi));
						hRHDeltaEtaSameLayer->Fill((me0DigiVector.at(l).g_eta - me0DigiVector.at(k).g_eta));
						hRHDeltaTSameLayer->Fill( me0DigiVector.at(l).tof - me0DigiVector.at(k).tof );
					}
				}
				
			}
		}
		//std::cout<<" NHIT SAME LAYER1= "<<NHitsSameLayer1.size()<<" NHIT SAME LAYER2= "<<NHitsSameLayer2.size()<<" NHIT SAME LAYER3= "<<NHitsSameLayer3.size()<<" NHIT SAME LAYER4= "<<NHitsSameLayer4.size()<<" NHIT SAME LAYER5= "<<NHitsSameLayer5.size()<<" NHIT SAME LAYER6= "<<NHitsSameLayer6.size()<<std::endl;
		
		if(Nrechit.size()) hNME0SegmentAfterDigiMatch->Fill(1);
		if((NMuAllHit.size()>0) &&  (NEleAllHit.size()>0)  && (NOtherAllHit.size()==0) ) {hSegmentComposition->SetBinContent(1,1); hMuEleinME0Segm->Fill(1);}
		if((NMuAllHit.size()>0) &&  (NEleAllHit.size()>0)  && (NOtherAllHit.size()>0)  ) {hSegmentComposition->SetBinContent(2,1); hMuEleOthersinME0Segm->Fill(1);}
		if((NMuAllHit.size()>0) &&  (NEleAllHit.size()==0) && (NOtherAllHit.size()==0) ) {hSegmentComposition->SetBinContent(3,1); hMuOnlyinME0Segm->Fill(1);}
		if((NMuAllHit.size()==0) &&  (NEleAllHit.size()>0) && (NOtherAllHit.size()>0) )  {hNoMuinME0Segm->Fill(1);}
		if((ME0SegmDIGIMatchedPhi.size()>0) && (NEleAllHit.size()>0)) hNEleBrem->Fill(1);
		if((ME0SegmDIGIMatchedPhi.size()==0) && (NEleAllHit.size()>0)) hNEleDeltaRays->Fill(1);
		if(NEleAllHit.size()) hNEle->Fill(1);
		
		std::cout<<" NRH="<<Nrechit.size()<<" nPrompt="<<NPromptHit.size()<<" nBkg="<<N_noPromptHit.size()<<" muHit="<<NPromptMuHit.size()<<" no mu prompt hit="<<NPromptNoMuHit.size()<<" MuonRH DPhi="<<me0RHPhiMuonOnly[0]-me0RHPhiMuonOnly[me0RHPhiMuonOnly.size()-1]<<" DX="<<fabs(me0RHXMuonOnly[0]-me0RHXMuonOnly[me0RHXMuonOnly.size()-1])<<endl;
		
		//std::cout<<" MatchedDigi with EleTrack size="<<ME0SegmDIGIMatchedPhi.size()<<" Ele Digi="<<NEleAllHit.size()<<std::endl;
		hNDigiMatchedRH->Fill(Nrechit.size());
		hNPrompt->Fill(NPromptHit.size());
		hN_noPrompt->Fill(N_noPromptHit.size());
		hNPromptMuHit->Fill(NPromptMuHit.size());
		hNPromptNoMuHit->Fill(NPromptNoMuHit.size());
		hN_noEleHit->Fill(N_noEleHit.size());
		
			hMuonDigiDPhiVsPT->Fill(fabs(me0RHPhiMuonOnly[0]-me0RHPhiMuonOnly[me0RHPhiMuonOnly.size()-1]), genparticles->at(minDRgen[m]).pt());
			hMuonDigiDXVsPT->Fill(fabs(me0RHXMuonOnly[0]-me0RHXMuonOnly[me0RHXMuonOnly.size()-1]), genparticles->at(minDRgen[m]).pt());
			
			hMuonDigiLocalDPhiVsPT->Fill(fabs(me0RHLocalPhiMuonOnly[0]-me0RHLocalPhiMuonOnly[me0RHLocalPhiMuonOnly.size()-1]), genparticles->at(minDRgen[m]).pt());
			hMuonDigiLocalDXVsPT->Fill(fabs(me0RHLocalXMuonOnly[0]-me0RHLocalXMuonOnly[me0RHLocalXMuonOnly.size()-1]), genparticles->at(minDRgen[m]).pt());
		
	
		
		
		hDPhi->Fill(me0RHPhiMuonOnly[0]-me0RHPhiMuonOnly[me0RHPhiMuonOnly.size()-1]);
		hDX->Fill(me0RHXMuonOnly[0]-me0RHXMuonOnly[me0RHXMuonOnly.size()-1]);
		
		hNoEleDigiDPhiVsPT->Fill(fabs(me0RHPhiNoEle[0]-me0RHPhiNoEle[me0RHPhiMuonOnly.size()-1]), genparticles->at(minDRgen[m]).pt());
		
		hPtVSDphi->Fill(fabs(me0RHPhi.at(0)-me0RHPhi.at(me0RHPhi.size()-1)), genparticles->at(minDRgen[m]).pt());
		hPtVSDEta->Fill(fabs(me0RHEta.at(0)-me0RHPhi.at(me0RHEta.size()-1)), genparticles->at(minDRgen[m]).pt());
		
		double DeltaPhiSimTrackFinal= (PhiSimMuonForCheck.at(0) - PhiSimMuonForCheck.at(PhiSimMuonForCheck.size()-1)) ;
		double DeltaPhiRecoMuonFinal= (me0RHPhi.at(0)-me0RHPhi.at(me0RHPhi.size()-1));
		
		hRecDPhiVSimDphi->Fill( DeltaPhiRecoMuonFinal ,  DeltaPhiSimTrackFinal );
		hDiffRecDPhiVSimDphi->Fill(DeltaPhiRecoMuonFinal -  DeltaPhiSimTrackFinal );
		 
		
		numME0RecHits.push_back(hitCounter);
		std::vector<double> simHitPhiForMatch;
		
		//for(me0DigiVector)
		//	for (uint k=0; k<ME0EleSimTracks.size(); k++){
		/*	
		 for (SimTrackContainer::const_iterator me0it = ME0Tracks.begin(); me0it  != ME0Tracks.end(); ++me0it ){
		 edm::PSimHitContainer selME0SimHitsforMatch = isTrackMatched(me0it, iEvent , iSetup);
		 
		 if( selME0SimHitsforMatch.size() ==0 ) continue;
		 simHitPhiForMatch.clear();
		 
		 for (edm::PSimHitContainer::const_iterator itHit =  selME0SimHitsforMatch.begin(); itHit != selME0SimHitsforMatch.end(); ++itHit){
		 //ME0DetId idme0 = ME0DetId(itHit->detUnitId());	
		 //int layer_sim = idme0.layer();		
		 LocalPoint lp = itHit->entryPoint();
		 GlobalPoint hitGP_sim( me0geom->idToDet( itHit->detUnitId())->surface().toGlobal(lp));		
		 simHitPhiForMatch.push_back(hitGP_sim.phi());
		 }
		 
		 }
		 
		 hNSimHitsME0->Fill(simHitPhiForMatch.size());
		 hNRecHitsME0->Fill(me0rhs.size());
		 hNBkgHitsME0->Fill( (me0rhs.size() -  simHitPhiForMatch.size()));
		 */
		
	}
	
	//fine loop me0 muon matchati
	
	//	std::cout<<"------------------# me0 matched muons with ID="<<idxMatchME0id.size()<<std::endl;
	
	hME0MuonsID->Fill(idxMatchME0id.size());
	hNEvZmm->Fill(counterZmm); 
	
	
	
	//////////////////////////////////////////////////////BeamSpot and VTX plot//////////////////////////////////////////////////////
	if ( beamSpotHandle.isValid() ){
		beamSpot = *beamSpotHandle;
		hBeamSpotX0->Fill(beamSpot.x0());
		hBeamSpotY0->Fill(beamSpot.y0());
		hBeamSpotX0Y0->Fill(beamSpot.x0(),beamSpot.y0());
		hBeamSpotZ0->Fill(beamSpot.z0());
		hBeamSpotSigmaZ->Fill( beamSpot.sigmaZ());
		hBeamSpotdxdz->Fill(beamSpot.dxdz());
		hBeamSpotBeamWidthX->Fill(beamSpot.BeamWidthX());
		hBeamSpotBeamWidthY->Fill(beamSpot.BeamWidthY());

	}
//	if (primaryVertices.isValid()) {
		hVertexMult->Fill(primaryVertices->size());		
		for (reco::VertexCollection::const_iterator it = primaryVertices->begin();  it != primaryVertices->end(); ++it) {			
			hverteX->Fill( it->x());
			hverteY->Fill( it->y());
			hverteXY->Fill( it->x(), it->y());
			hverteZ->Fill( it->x());
		}
//}
	//////////////////////////////////////////////////////BeamSpot and VTX plot//////////////////////////////////////////////////////
	//	}
}



// ------------ method called once each job just before starting event loop  ------------
void 
ME0SegmentAnalyzer::beginJob()
{
	hNEvZmm = fs->make<TH1F>("hNEvZmm","hNEvZmm",10,0,10); 
	hNSimHitsME0= fs->make<TH1F>("hNSimHitsME0","hNSimHitsME0",20,0,20); 
	hNRecHitsME0= fs->make<TH1F>("hNRecHitsME0","hNRecHitsME0",100,0,100);
	hNBkgHitsME0= fs->make<TH1F>("hNBkgHitsME0","hNBkgHitsME0",60,-10,50);
	
	hNDigiMatchedRH= fs->make<TH1F>("hNDigiMatchedRH","hNDigiMatchedRH",21,-0.5,20.5);
	hNPrompt= fs->make<TH1F>("hNPrompt","hNPrompt",21,-0.5,20.5);
	hN_noPrompt= fs->make<TH1F>("hN_noPrompt","hN_noPrompt",21,-0.5,20.5);
	
	hRatioRecoToSimHits= fs->make<TH1F>("hRatioRecoToSimHits","hRatioRecoToSimHits",1000,0,100);
	
	hNPromptMuHit= fs->make<TH1F>("hNPromptMuHit","hNPromptMuHit",21,-0.5,20.5);
	hNPromptNoMuHit= fs->make<TH1F>("hNPromptNoMuHit","hNPromptNoMuHit",21,-0.5,20.5);
	hNPromptHit_pdgId= fs->make<TH1F>("hNPromptHit_pdgId","hNPromptHit_pdgId",3001,0,3000.5);
	hN_noPromptHit_pdgId= fs->make<TH1F>("hN_noPromptHit_pdgId","hN_noPromptHit_pdgId",3001,0,3000.5);
	hN_noEleHit= fs->make<TH1F>("hN_noEleHit","hN_noEleHit",21,-0.5,20.5);
	
	hSimEta  = fs->make<TH1F>("hSimEta","hSimEta",100,-4,4);  
	hSimPt  = fs->make<TH1F>("hSimPt","hSimPt",200, 0,200);  
	hPtVSDphi = fs->make<TH2F>("hPtVSDphi","hPtVSDphi",5000, 0, 0.05 , 200,0,200); 
	hSimPtVSDphi = fs->make<TH2F>("hSimPtVSDphi","hSimPtVSDphi",5000, 0, 0.05 , 200,0,200); 
	hSimPtVSDeta = fs->make<TH2F>("hSimPtVSDeta","hSimPtVSDeta",10000, 0, 0.1 , 200,0,200); 
	hSimDEta = fs->make<TH1F>("hSimDEta","hSimDEta",1000,-0.5,0.5);  
	hSimDPhi = fs->make<TH1F>("hSimDPhi","hSimDPhi",1000,-0.5,0.5);  
	hSimDX = fs->make<TH1F>("hSimDX","hSimDX",1000,-20,20);  
	hSimDY = fs->make<TH1F>("hSimDY","hSimDY",1000,-20,20);  
	
	hMuonDigiDPhiVsPT= fs->make<TH2F>("hMuonDigiDPhiVsPT","hMuonDigiDPhiVsPT", 5000, 0, 0.05 , 200,0,200); 
	hMuonDigiDXVsPT= fs->make<TH2F>("hMuonDigiDXVsPT","hMuonDigiDXVsPT", 5000, 0, 20. , 200,0,200); 
	
	hMuonDigiLocalDPhiVsPT= fs->make<TH2F>("hMuonDigiLocalDPhiVsPT","hMuonDigiLocalDPhiVsPT", 5000, 0, 0.1 , 200,0,200); 
	hMuonDigiLocalDXVsPT= fs->make<TH2F>("hMuonDigiLocalDXVsPT","hMuonDigiLocalDXVsPT", 5000, 0, 20. , 200,0,200); 

	
	hNoEleDigiDPhiVsPT= fs->make<TH2F>("hNoEleDigiDPhiVsPT","hNoEleDigiDPhiVsPT", 5000, 0, 0.05 , 200,0,200); 
	
	hAbsDPhi = fs->make<TH1F>("hAbsDPhi","hAbsDPhi",1000,0.,0.5);  
	hAbsDEta = fs->make<TH1F>("hAbsDEta","hAbsDEta",1000,0.,0.5);  
	hDEta = fs->make<TH1F>("hDEta","hDEta",1000,-0.5,0.5);  
	hDPhi = fs->make<TH1F>("hDPhi","hDPhi",1000,-0.1,0.1);  
	hDX = fs->make<TH1F>("hDX","hDX",1000,-20,20);  
	
	hPtVSDEta = fs->make<TH2F>("hPtVSDeta","hPtVSDeta",5000, 0, 0.1 , 200,0,200);
	
	
	hme0machtMuonPt = fs->make<TH1F>("hme0machtMuonPt","hme0machtMuonPt",200,0,200);  
	hme0machtMuonEta= fs->make<TH1F>("hme0machtMuonEta","hme0machtMuonEta",200,-4,4);  
	hme0machtMuonPhi= fs->make<TH1F>("hme0machtMuonPhi","hme0machtMuonPhi",200,-4,4);  
	hme0machtMuonCharge= fs->make<TH1F>("hme0machtMuonCharge","hme0machtMuonCharge",10,-5,5);  
	hNME0Time = fs->make<TH1F>("hNME0Time","hNME0Time",300,0,300);  
	hNME0RecHits = fs->make<TH1F>("hNME0RecHits","hNME0RecHits",100,0,100); 
	
	hNzmm  = fs->make<TH1F>("hNzmm","hNzmm",10,0,10); 
	hNEv  = fs->make<TH1F>("hNEv","hNEv",10,0,10); 
	hNGenMu = fs->make<TH1F>("hNGenMu","hNGenMu",10,0,10); 
	hNME0Mu = fs->make<TH1F>("hNME0Mu","hNME0Mu",10,0,10);
	hNMatchME0Mu = fs->make<TH1F>("hNMatchME0Mu","hNMatchME0Mu",10,0,10);
	
	hPVSDphi  = fs->make<TH2F>("hPVSDPhi","hPVSDPhi",1000, 0, 0.01 , 200,0,200); 
	
	
	hPtVSDX = fs->make<TH2F>("hPtVSDX","hPtVSDX",1000, 0, 10 , 200,0,200); 
	hPtVSDY = fs->make<TH2F>("hPtVSDY","hPtVSDY",1000, 0, 10 , 200,0,200); 
	
	
	hPtVSDXLocal = fs->make<TH2F>("hPtVSDXLocal","hPtVSDXLocal",1000, 0, 10 , 200,0,200); 
	hPtVSDYLocal =  fs->make<TH2F>("hPtVSDYLocal","hPtVSDYLocal",1000, 0, 10 , 200,0,200);
	
	
	
	hGenMuPt = fs->make<TH1F>("hGenMuPt","hGenMuPt",200,0,200);
	hGenMuEta = fs->make<TH1F>("hGenMuEta","hGenMuEta",200,0,4);
	
	hNumTight_Pt = fs->make<TH1F>("hNumTight_Pt","hNumTight_Pt",200,0,200);
	hNumTight_Eta = fs->make<TH1F>("hNumTight_Eta","hNumTight_Eta",200,0,4);
	hNumLoose_Pt = fs->make<TH1F>("hNumLoose_Pt","hNumLoose_Pt",200,0,200);
	hNumLoose_Eta = fs->make<TH1F>("hNumLoose_Eta","hNumLoose_Eta",200,0,4);
	hNumNoID_Eta = fs->make<TH1F>("hNumNoID_Eta","hNumNoID_Eta",200,0,4);
	hNumNoID_Pt = fs->make<TH1F>("hNumNoID_Pt","hNumNoID_Pt",200,0,200);
	
	hGenMass =  fs->make<TH1F>("hGenMass","hGenMass",200,0,200);
	hRecoMass =  fs->make<TH1F>("hRecoMass","hRecoMass",200,0,200);
	hRecoMassIntime =  fs->make<TH1F>("hRecoMassIntime","hRecoMassIntime",200,0,200);
	hRecoMass_matchID = fs->make<TH1F>("hRecoMass_matchID","hRecoMass_matchID",200,0,200);
	
	hSelectedSimTrack =  fs->make<TH1F>("hSelectedSimTrack","hSelectedSimTrack",20,0,20);
	hNME0Segment =  fs->make<TH1F>("hNME0Segment","hNME0Segment ",20,0,20);
	hGenMuonsME0= fs->make<TH1F>("hGenMuonsME0","hGenMuonsME0",20,0,20);
	hME0MuonsInMatchCone = fs->make<TH1F>("hME0MuonsInMatchCone","hME0MuonsInMatchCone",20,0,20);
	hME0MuonsID = fs->make<TH1F>("hME0MuonsID","hME0MuonsID",20,0,20);
	hME0SimTrackPdgID = fs->make<TH1F>("hME0SimTrackPdgID","hME0SimTrackPdgID",3000,0,3000);
	
	hSimElePtME0  = fs->make<TH1F>("hSimElePtME0","hSimElePtME0",100,0,10);			
	hSimMuPtME0   = fs->make<TH1F>("hSimMuPtME0","hSimMuPtME0",100,0,100);
	hSimPionPtME0 = fs->make<TH1F>("hSimPionPtME0","hSimPionPtME0",100,0,10);
	
	hSimEleNHitsME0 = fs->make<TH1F>("hSimEleNHitsME0","hSimEleNHitsME0",10,0,10);	
	hSimMuonNHitsME0 = fs->make<TH1F>("hSimMuonNHitsME0","hSimMuonNHitsME0",10,0,10);
	hSimPionNHitsME0 = fs->make<TH1F>("hSimPionNHitsME0","hSimPionNHitsME0",10,0,10);
	hPdgIDCheck= fs->make<TH1F>("hPdgIDCheck","hPdgIDCheck",220,0,220);
	hDRME0SimTrack  = fs->make<TH1F>("hDRME0SimTrack","hDRME0SimTrack",200,0,10);
	hDRME0SimMuonEle= fs->make<TH1F>("hDRME0SimMuonEle","hDRME0SimMuonEle",200,0,10);
	
	hNME0SegmentAfterDigiMatch= fs->make<TH1F>("hNME0SegmentAfterDigiMatch","hNME0SegmentAfterDigiMatch",3,0,3);
	hSegmentComposition= fs->make<TH1F>("hSegmentComposition","hSegmentComposition",3,0,3);
	hSegmentComposition->GetXaxis()->SetBinLabel(1,"13 || 11");
	hSegmentComposition->GetXaxis()->SetBinLabel(2,"13 || 11 || >200");
	hSegmentComposition->GetXaxis()->SetBinLabel(3,"13 only");
	
	hMuEleinME0Segm = fs->make<TH1F>("hMuEleinME0Segm","hMuEleinME0Segm",3,0,3);
	hMuEleOthersinME0Segm = fs->make<TH1F>("hMuEleOthersinME0Seg","hMuEleOthersinME0Seg",3,0,3);
	hMuOnlyinME0Segm = fs->make<TH1F>("hMuOnlyinME0Segm","hMuOnlyinME0Segm",3,0,3);
	hNoMuinME0Segm= fs->make<TH1F>("hNoMuinME0Segm","hNoMuinME0Segm",3,0,3);
	
	hNEleBrem= fs->make<TH1F>("hNEleBrem","hNEleBrem",3,0,3);
	hNEleDeltaRays= fs->make<TH1F>("hNEleDeltaRays","hNEleDeltaRays",3,0,3);
	hNEle= fs->make<TH1F>("hNEle","hNEle",3,0,3);
	hMatchedSimEleTrack= fs->make<TH1F>("hMatchedSimEleTrack","hMatchedSimEleTrack",100,0,5);
	
	hRHDeltaPhiSameLayer= fs->make<TH1F>("hRHDeltaPhiSameLayer","hRHDeltaPhiSameLayer",1000,-0.1,0.1);
	hRHDeltaEtaSameLayer= fs->make<TH1F>("hRHDeltaEtaSameLayer","hRHDeltaEtaSameLayer",1000,-0.5,0.5);
	hRHDeltaTSameLayer= fs->make<TH1F>("hRHDeltaTSameLayer","hRHDeltaTSameLayer",1000,-5,5);
	
	hNMuonSameLayerTOF = fs->make<TH1F>("hNMuonSameLayerTOF","hNMuonSameLayerTOF",1000,0,100);
	hNEleSameLayerTOF = fs->make<TH1F>("hNEleSameLayerTOF","hNEleSameLayerTOF",1000,0,100);
	hNoPromptSameLayerTOF = fs->make<TH1F>("hNoPromptLayerTOF","hNoPromptLayerTOF",1000,0,100);
	
	hNoPromptRecHitTime= fs->make<TH1F>("hNoPromptRecHitTime","hNoPromptRecHitTime",1000,0,100);
	hMuonRecHitTime= fs->make<TH1F>("hMuonRecHitTime","hMuonRecHitTime",1000,0,100);
	hEleRecHitTime= fs->make<TH1F>("hEleRecHitTime","hEleRecHitTime",1000,0,100);
	
	
	hDeltaPhiSimReco =  fs->make<TH1F>("hDeltaPhiSimReco","hDeltaPhiSimReco",1000,-0.1,0.1);
	hDeltaEtaSimReco =  fs->make<TH1F>("hDeltaEtaSimReco","hDeltaEtaSimReco",1000,-1,1);
	hDeltaXSimReco =  fs->make<TH1F>("hDeltaXSimReco","hDeltaXSimReco",1000,-1,1);
	hDeltaYSimReco =  fs->make<TH1F>("hDeltaYSimReco","hDeltaYSimReco",1000,-1,1);
	
	hDeltaXSimRecoLocal = fs->make<TH1F>("hDeltaXSimRecoLocal","hDeltaXSimRecoLocal",1000,-1,1);
	hDeltaYSimRecoLocal =  fs->make<TH1F>("hDeltaYSimRecoLocal","hDeltaYSimRecoLocal",1000,-1,1);
								   
	hRecDPhiVSimDphi=fs->make<TH2F>("hRecDPhiVSimDphi","hRecDPhiVSimDphi",1000, -0.01, 0.01 , 1000, -0.01, 0.01); 
	hDiffRecDPhiVSimDphi =  fs->make<TH1F>("hDiffRecDPhiVSimDphi","hDiffRecDPhiVSimDphi",500,-0.05,0.05);
	
	hBeamSpotX0 =  fs->make<TH1F>("hBeamSpotX0","hBeamSpotX0",1000,-10,10);
	hBeamSpotY0 =  fs->make<TH1F>("hBeamSpotY0","hBeamSpotY0",1000,-10,10);
	hBeamSpotX0Y0 =  fs->make<TH2F>("hBeamSpotX0Y0","hBeamSpotX0Y0",1000,-10,10,1000,-10,10);
	hBeamSpotZ0 = fs->make<TH1F>("hBeamSpotZ0","hBeamSpotZ0",1000,-30,30);
	hBeamSpotSigmaZ = fs->make<TH1F>("hBeamSpotSigmaZ","hBeamSpotSigmaZ",1000,-30,30);
	hBeamSpotdxdz  = fs->make<TH1F>("hBeamSpotdxdz","hBeamSpotdxdz",1000,-30,30);
	hBeamSpotBeamWidthX = fs->make<TH1F>("hBeamSpotBeamWidthX","hBeamSpotBeamWidthX",1000,-30,30);
	hBeamSpotBeamWidthY = fs->make<TH1F>("hBeamSpotBeamWidthY","hBeamSpotBeamWidthY",1000,-30,30);
	hVertexMult  = fs->make<TH1F>("hVertexMult","hVertexMult",100,0,300);		
	hverteX  = fs->make<TH1F>("hverteX","hverteX",100,-10,10);
	hverteY  = fs->make<TH1F>("hverteY","hverteY",100,-10,10);
	hverteXY  = fs->make<TH2F>("hverteXY","hverteXY",100,-10,10,100, -10,10 );
	hverteZ = fs->make<TH1F>("hverteZ","hverteZ",100,-30,30);
								   
								  

}



// ------------ method called once each job just after ending the event loop  ------------
void 
ME0SegmentAnalyzer::endJob() 
{
	/*
	 rootfile->cd();
	 mytree->Write();
	 rootfile->Close();*/
	
}

// ------------ method called when starting to processes a run  ------------

//void ME0SegmentAnalyzer::beginRun(edm::Run const&, edm::EventSetup const&)
//{



// ------------ method called when ending the processing of a run  ------------
/*
 void 
 ME0SegmentAnalyzer::endRun(edm::Run const&, edm::EventSetup const&)
 {
 }
 */

// ------------ method called when starting to processes a luminosity block  ------------
/*
 void 
 ME0SegmentAnalyzer::beginLuminosityBlock(edm::LuminosityBlock const&, edm::EventSetup const&)
 {
 }
 */

// ------------ method called when ending the processing of a luminosity block  ------------
/*
 void 
 ME0SegmentAnalyzer::endLuminosityBlock(edm::LuminosityBlock const&, edm::EventSetup const&)
 {
 }
 */

// ------------ method fills 'descriptions' with the allowed parameters for the module  ------------
void
ME0SegmentAnalyzer::fillDescriptions(edm::ConfigurationDescriptions& descriptions) {
	//The following says we do not know what parameters are allowed so do no validation
	// Please change this to state exactly what you do use, even if it is no parameters
	edm::ParameterSetDescription desc;
	desc.setUnknown();
	descriptions.addDefault(desc);
}

//define this as a plug-in
DEFINE_FWK_MODULE(ME0SegmentAnalyzer);
